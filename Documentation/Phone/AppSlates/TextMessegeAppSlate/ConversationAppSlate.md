# ConversationAppSlate
extends AppSlate

ConversationAppSlate it a 'component' of the TextMessageAppSlate. Instead of handling each and every conversation and its rendering and its data, each individual conversation partner is handled by several component Nodes instead.

The ConversationAppSlate handles parsing conversations with a specific partner through a ConversationPartner and then displaying those conversataion pieces through RichTextLabels. While data for the conversation is parsed and displayed by the ConversationAppSlate, which partner to display, when, and how far into the conversation to start is up to other parts of the system.

ConversationAppSlate extends AppSlate because it's intended for the ConversationAppSlate to be placed in the center of the screen over/in place of the TextMessageAppSlate when selected, but that hasn't been implemented yet.

(How all of the component nodes works hasn't been worked out yet, and probably won't be until TextMessageAppSlate is fully implemented with the other two.)

btw, _fields_ and _child nodes_ are _italics_, while **functions** and **signals** are **bold**.

### Fields
prompt_control_scene: The scene for PromptControl, so that Prompts can be created when prompt data is provided in a conversation_dict.

convo_type: The script for ConversationParser, so that ConversationParsers can be instanced. This is called 'convo_type' because it's used to access the ConversationParser JSONFields enum. Which is kinda like what you'd do if ConversationParser was a type_name'd type, and not just a preload.

prompt_completed_receiver_name: Name of the method used to receive 'PromptCompleted' signals from Prompts generated by this conversation.

text_parent_control: The VBoxContainer that text messages should be parented to.

prompt_parent_control: The control that Prompts should be parented to.

convoJSON_resource: The resource file containing the conversation JSON that the ConversationAppSlate is going to display.

convo_parser: The ConversationParser this ConversationAppSlate is using to generate conversation data.

entry_parent: The ConversationEntry node associated with the ConversationAppSlate. It's called the 'parent' because the Entry should be the AppSlate's node tree parent.

active_convo_dict: The convo_dict provided by the ConversationParser. Unless we're actively getting new data from the ConversationParser, the active_convo_dict contains all the data we need for a conversation at that certain step.

active_convo_index: The JSONField.CONVERSATIONINDEX of _active_convo_dict_. This index is used to reference progress through the conversation without needing to store the entire thing.

active_prompt_control: If the conversation has generated a Prompt, it gets stored here.

starting_convo_index: The index of the convo_dict the ConversationAppSlate should started at when told to start for the first time in its lifetime.

### Child Nodes
VBoxContainer: Vertical organizer for the entire appslate.

VBoxContainer/HeaderControl: UI Control for any header UI elements.

VBoxContainer/HeaderControl/Panel: Visual Aid to show size of HeaderControl.

VBoxContainer/HeaderControl/Panel/MockPartnerLabel: A mock label that holds the conversation partner's name. In the future, there may be more stuff here. We'll see.

VBoxContainer/TextControl: UI Control for text elements (anything relating to the actual conversation).

VBoxContainer/TextControl/TextVBoxContainer: Vertical organizer for text message controls (not the messages themselves, and prompts.

VBoxContainer/TextControl/TextVBoxContainer/ScrollContainer: Adds scrolling to text messages so previous messages can be reviewed (and because it makes it reeeeeeeeeaaaaaaaaalllllyyy easy to just keep stuffing the VBoxContainer with RichTextLabels).

VBoxContainer/TextControl/TextVBoxContainer/ScrollContainer/VBoxContainer: Vertically organizes all of the RichTextLabels that contain actual text message text.

TextControl/TextVBoxContainer/PromptControl: UI Control for any Prompts generated by the conversation. 

TextControl/FooterControl: UI Control for any footer UI elements. So far, that's 'none', but who knows, maybe this'll be useful in the future.

TextControl/FooterControl/Panel: Visual Aid to show size of FooterControl.

## func initialize_convo_slate(new_convoJSON_resource : Resource, new_entry_node : Node, new_starting_index : int = 0):
Constructor. Saves the arguments to their corresponding field:
- convoJSON_resource = new_convoJSON_resource
- entry_parent = new_entry_node
- starting_convo_index = new_starting_index
	
## func _ready():
Called when the node enters the scene tree. So far, does nothing. But I might want it to do something down the line, so it's still here for right now.

## end_convo_slate() -> int:
Called when the convo_slate is about to be freed by something else (this isn't called automatically on free). Currently, just returns **_get_active_convo_index()**
	
## func start_convo_slate():
Starts up the convo_slate with the following algorithm:

1. Checks if the resource in _convoJSON_resource_ is actually a ConversationJSONData.
2. Creates a new ConversationParser around _convoJSON_resource_
3. Parses the JSON resource into conversation chunks using _convo_parser_
4. Calls **display_pregenerated_data()** to display any info that should be part of the conversation before the conversation continues normally.
5. Pops the next convo_dict with **pop_process_convo_dict()**. This is the point at which conversation chunks start being processed automatically.

## func display_pregenerated_data():
For right now, sets up the _MockPartnerLabel_ with _conversation_parser.conversation_partner_.

Also fasts forward the conversation to the last active conversation by calling **create_static_message_text()** on every conversation chunk before the _starting_convo_index_ (unless _starting_convo_index_ is 0, then this step is skipped).

## func pop_process_convo_dict():
Calls **process_convo_dict(convo_parser.get_next_conversation_chunck())**. Just a convenient way to process whatever the next conversation chunk is.

## func process_convo_dict(convo_dict):
Takes the incoming convo_dict and decides what to do with it.

This method primarly just checks to make sure this convo_dict isn't EOF. If it isn't, it is saved as the _active_convo_dict_ and its index as the _active_convo_index_. The display requirement information need to show the conversation is then passed to _entry_parent_ by calling **init_entry_node_display_conditions()**.

## func display_next_convo_dict():
Calls **create_static_message_text(active_convo_dict)** (which displays the actual text of the _active_convo_dict_), then **pop_process_convo_dict()** to generate the next one.
	
## func create_static_message_text(convo_dict):
Calls **make_static_message_label(_convo_dict[convo_type.JSONFields.PARTNERMESSAGETEXT])**  and then childs the RichTextLabel to _text_parent_control_

If the _convo_dict_ also has a Prompt in it, the same thing is done with _convo_dict[convo_type.JSONFields.PROMPTCONTENTS][convo_type.JSONFields.LEXMESSAGETEXT]_ and [right][/right] formatting.

## func make_static_message_label(bb_text : String) -> RichTextLabel:
Creates a RichTextLabel called rt. rtl has its _bbcode_enabled_ and _fit_content_height_ to true, and its _bbcode_text_ ti _bb_text_. rtl is then returned.

## func create_lex_prompt():
Uses the _active_convo_dict[convo_type.JSONFields.PROMPTCONTENTS]_ to generate and init a PromptControl from _prompt_control_scene_ and child it to _prompt_parent_control_.

Also starts the repeat notification timer with **send_repush_timer_to_entry_node()** so that the player remembers to do the prompt.

## func init_entry_node_display_conditions():
Sets up the _entry_node_ display conditions (the things that need to happen before the message is sent) by doing two things:

1. Starting the initial delay timer to display contents with **send_first_timer_to_entry_node()**.
2. Calling **entry_parent.create_game_story_beat_requirements(active_convo_dict[convo_type.JSONFields.TRIGGERSTORYBEAT], 0)** to inform the _entry_parent_ of which story beat to wait for (_active_convo_dict[convo_type.JSONFields.TRIGGERSTORYBEAT]_ and how frequently it needs to have occurred (currently 0, as GSB freqeuncy measuring hasn't been implemented yet).
	
## func send_first_timer_to_entry_node():
Calls **entry_parent.create_first_push_timer(active_convo_index, active_convo_dict[convo_type.JSONFields.FIRSTPUSHTIME])**, and does any other Slate-specific timer set up that is required.
	
## func send_repush_timer_to_entry_node():
Calls **entry_parent.create_repush_push_timer(active_convo_index, active_convo_dict[convo_type.JSONFields.REPUSHTIME])**, and does any other Slate-specific timer set up that is required.
	
## func stop_timer_on_entry_node():
Calls **entry_parent.cancel_repush_timer(active_convo_index)**, and does any other Slate-specific timer teardown that is required.

## func handle_next_convo_dict() -> String:
Called when the _active_convo_dict_'s data should be displayed. If it contains a prompt, calls **create_lex_prompt()**. If not, calls **display_next_convo_dict()**.

The important difference here is that **display_next_convo_dict** will advance to the next convo_dict automatically, while **create_lex_prompt()** waits for the prompt that _active_convo_dict_ to be completed before moving on (to the next convo_dict, the method is not asynchronous).
	
Returns _active_convo_dict[convo_type.JSONFields.PARTNERMESSAGETEXT]_

## func handle_prompt_completed():
Stops the repush timer with **stop_timer_on_entry_node**, frees the _active_prompt_control_, and then displays the text in _active_convo_dict_ with **display_next_convo_dict()**. 

Again, **display_next_convo_dict()** pops the next conversation chunk into _active_convo_dict_ once the text of the _active_convo_dict_ is displayed.

## func get_current_convo_dict_send_story_beat() -> int:
Returns _active_convo_dict[convo_type.JSONFields.SENDSTORYBEAT]_

## func _get_active_convo_index() -> int:
Getter for _active_convo_index_. If there is an _active_convo_dict_, returns that convo_dict's CONVERSATIONINDEX. If there isn't an _active_convo_dict_, returns _starting_convo_index_ instead.

## func _on_PromptControl_completed():
Called when _active_prompt_control_ emits its PromptCompleted signal. Calls **handle_prompt_completed()**